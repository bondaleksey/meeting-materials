# GIL (Global Interpreter Lock) в Python

Кратко: GIL не дает Python-процессу исполнять более одной команды байт-кода в каждый момент времени.

GIL (Global Interpreter Lock) в Python — это механизм, который предотвращает одновременное выполнение байт-кода нескольких потоков в одном процессе интерпретатора.

Зачем нужен GIL:

GIL был введён для упрощения управления памятью и обеспечения безопасности при работе с объектами Python. В многопоточной среде без GIL могли бы возникнуть проблемы с доступом к общим данным и нарушением целостности состояния объектов. GIL позволяет избежать таких ситуаций, так как только один поток может владеть интерпретатором и выполнять код в любой момент времени.

Ограничения GIL:

1. Ограничение параллелизма: GIL не позволяет потокам в Python выполняться параллельно на многоядерных процессорах. Даже если у вас есть несколько потоков, выполняющих процессорно-ёмкие задачи, они будут выполняться последовательно, что может снизить производительность.

2. Неэффективное использование многоядерности: из-за GIL потоки в Python не могут использовать все ядра процессора для вычислений, что ограничивает возможности масштабирования приложений на многопроцессорных системах.

3. Влияние на производительность: GIL может снижать производительность приложений, особенно если они выполняют много вычислений в цикле или работают с большими объёмами данных. Это связано с тем, что потоки должны ждать своей очереди, чтобы получить доступ к интерпретатору.

Плюсы GIL:

1. Упрощение управления памятью: GIL упрощает управление памятью и предотвращает проблемы, связанные с одновременным доступом к объектам. Это делает код более безопасным и надёжным.

2. Совместимость с расширениями: многие расширения Python могут не быть готовы к работе в полностью потокобезопасном окружении. GIL обеспечивает совместимость с такими расширениями, которые могут не обрабатывать состояние гонки или другие проблемы, связанные с многопоточностью.

3. Простота разработки: GIL избавляет разработчиков от необходимости вручную управлять блокировками и синхронизацией потоков, что может упростить разработку некоторых типов приложений.


CPython не является потокобезопасным. Если два или более потоков модифицируют разделяемую переменную, то ее конечное состояние может оказаться неожиданным, поскольку зависит от порядка доступа к переменной со стороны потоков. Эта ситуация называется состоянием гонки. Состояния гонки могут возникать, когда два потока одновременно обращаются к одному объекту Python.

Глобальная блокировка интерпретатора освобождается на время выполнения операций ввода-вывода. Это позволяет использовать потоки для конкурентного выполнения ввода-вывода, но не для выполнения счетного кода, написанного на Python (есть исключения, когда GIL все же освобождается на время выполнения счетных задач)


Так почему же GIL освобождается при вводе-выводе, но не освобождается для счетных задач?

Все дело в системных вызовах, которые выполняются за кулисами. В случае ввода-вывода низкоуровневые системные вызовы работают за пределами среды выполнения Python. Это позволяет освободить GIL, потому что код операционной системы не взаимодействет напрямую с объектами Python. GIL захватывается снова, только когда полученные данные переносятся в объект Python. Стало быть, на уровне ОС операции ввода-вывода выполняются конкурентно.